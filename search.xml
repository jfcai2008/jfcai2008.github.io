<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>永不放弃</title>
    <url>/2021/02/04/%E6%B0%B8%E4%B8%8D%E6%94%BE%E5%BC%83/</url>
    <content><![CDATA[<p>不断失败，不停尝试。</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>注定平穷</title>
    <url>/2021/02/04/%E6%B3%A8%E5%AE%9A%E5%B9%B3%E7%A9%B7/</url>
    <content><![CDATA[<p>这辈子不会成为有钱人了！</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>我的IT职场末路</title>
    <url>/2021/02/04/%E6%88%91%E7%9A%84IT%E8%81%8C%E5%9C%BA%E6%9C%AB%E8%B7%AF/</url>
    <content><![CDATA[<p>我在为猖狂支付代价。<br>我在为…</p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>小心职途之小人得意之忘形</title>
    <url>/2021/02/04/%E5%B0%8F%E5%BF%83%E8%81%8C%E9%80%94%E4%B9%8B%E5%B0%8F%E4%BA%BA%E5%BE%97%E6%84%8F%E4%B9%8B%E5%BF%98%E5%BD%A2/</url>
    <content><![CDATA[<p>成功时不得意，失败时不气馁。  </p>
<p>想想成功是集体的力量，还是自己的本事？  </p>
<p>离开了团队你还能成功吗？  </p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>在nodejs中使用websocket</title>
    <url>/2021/02/07/%E5%9C%A8nodejs%E4%B8%AD%E4%BD%BF%E7%94%A8websocket/</url>
    <content><![CDATA[<p>软件环境：<br>服务端：nodejs<br>客户端：angular9  </p>
<a id="more"></a>
<h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><h5 id="创建文件SockerUse-class-js"><a href="#创建文件SockerUse-class-js" class="headerlink" title="创建文件SockerUse.class.js"></a>创建文件SockerUse.class.js</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const logger &#x3D; require(&quot;..&#x2F;helper&#x2F;LogHelper.class&quot;)</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @description socket处理文件</span><br><span class="line"> * 使用方法：若需要使用websocker</span><br><span class="line"> * 则在应用中加入</span><br><span class="line">      if(useWebSocket) &#123;</span><br><span class="line">        const &#123;SocketUtil&#125; &#x3D; require(&quot;.&#x2F;SocketUse.class&quot;)</span><br><span class="line">        const socket &#x3D; new SocketUtil(server)</span><br><span class="line">        socket.connect()</span><br><span class="line">        let config &#x3D; require(&quot;..&#x2F;config&#x2F;soccer.config&quot;)</span><br><span class="line">        config.SocketTool.Instance &#x3D; socket.SocketTool</span><br><span class="line">        logger.info(&#96;start websoket on port:$&#123;this.port&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line"> 然后在SocketDispatcher中定义或处理消息即可。</span><br><span class="line"> *&#x2F;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * @description 将消息发送到客户端</span><br><span class="line"> * @param dataInfo</span><br><span class="line"> * @constructor</span><br><span class="line"> *&#x2F;</span><br><span class="line">const SendData2Client &#x3D; function (dataInfo) &#123;</span><br><span class="line">    if (SOCKETS &amp;&amp; SOCKETS.length &gt; 0) &#123;</span><br><span class="line">        logger.info(&#96;共有$&#123;SOCKETS.length&#125;个客户端，需要推送数据。&#96;)</span><br><span class="line">        for (let i &#x3D; 0; i &lt; SOCKETS.length; i++) &#123;</span><br><span class="line">            SOCKETS[i].socket.emit(&#39;svcMsg&#39;, dataInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">let SOCKETS &#x3D; []</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @description socker.io的消息处理类</span><br><span class="line"> *&#x2F;</span><br><span class="line">class SocketDispatcher &#123;</span><br><span class="line">    constructor() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @description socket连接后处理</span><br><span class="line">     * @param socket</span><br><span class="line">     * @returns &#123;Promise&lt;void&gt;&#125;</span><br><span class="line">     *&#x2F;</span><br><span class="line">    async socketConnect(socket) &#123;</span><br><span class="line">        logger.info(&#39;------------USER CONNECTED--------------&#39;)</span><br><span class="line">        socket.emit(&#39;welcome&#39;, &#39;hello,welcome use this application&#39;)</span><br><span class="line">        socket.on(&#39;disconnect&#39;, function (data) &#123;</span><br><span class="line">            logger.info(&#96;用户：$&#123;socket.id&#125; 断开！&#96;)</span><br><span class="line">            let pos &#x3D; -1</span><br><span class="line">            for (let i &#x3D; 0; i &lt; SOCKETS.length; i++) &#123;</span><br><span class="line">                if (SOCKETS[i].socket.id &#x3D;&#x3D;&#x3D; socket.id) &#123;</span><br><span class="line">                    pos &#x3D; i</span><br><span class="line">                    break</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (pos !&#x3D;&#x3D; -1) &#123;</span><br><span class="line">                SOCKETS.splice(pos, 1)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        socket.on(&#39;clientMsg&#39;, function (data) &#123;</span><br><span class="line">            logger.info(data)</span><br><span class="line">        &#125;)</span><br><span class="line">        socket.on(&#39;CurrentRoleID&#39;, function (data) &#123;</span><br><span class="line">            let currentRoleId &#x3D; data</span><br><span class="line">            let ss &#x3D; SOCKETS.filter(s &#x3D;&gt; &#123;</span><br><span class="line">                return s.socket.id &#x3D;&#x3D;&#x3D; socket.id</span><br><span class="line">            &#125;)</span><br><span class="line">            if (ss &amp;&amp; ss.length &gt; 0) &#123;</span><br><span class="line">                ss[0].currentRoleId &#x3D; data.roleId</span><br><span class="line">                ss[0].UserName &#x3D; data.userName</span><br><span class="line">                logger.info(&#96;当前用户信息:roleId&#x3D;$&#123;ss[0].currentRoleId&#125;,userName&#x3D;$&#123;ss[0].UserName&#125;,sid&#x3D;$&#123;ss[0].socket.id&#125;&#96;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">        SOCKETS.push(&#123;socket: socket, currentRoleId: -1, UserName: &#39;&#39;&#125;)</span><br><span class="line">        logger.warn(&#96;用户：$&#123;socket.id&#125; 上线！,当前人数：$&#123;SOCKETS.length&#125;&#96;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @description socker消息发送</span><br><span class="line">     * @param dataInfo</span><br><span class="line">     * @constructor</span><br><span class="line">     *&#x2F;</span><br><span class="line">    SocketSend(dataInfo) &#123;</span><br><span class="line">        SendData2Client(dataInfo)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * @description socker.io对象类。用来启动socker服务。</span><br><span class="line"> *&#x2F;</span><br><span class="line">class SocketUtil &#123;</span><br><span class="line">    get SocketTool() &#123;</span><br><span class="line">        return this.sktool</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    constructor(server) &#123;</span><br><span class="line">        &#x2F;&#x2F; 接收定义好的 server</span><br><span class="line">        this.server &#x3D; server;</span><br><span class="line">        this.sktool &#x3D; new SocketDispatcher()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * @description 启动websocket服务侦听。定义连接响应对像</span><br><span class="line">     *&#x2F;</span><br><span class="line">    connect() &#123;</span><br><span class="line">        &#x2F;&#x2F; 引入socket.io模块,并创建io</span><br><span class="line">        logger.info(&#39;begin websocket listening....&#39;)</span><br><span class="line">        var io &#x3D; require(&#39;socket.io&#39;, &#123;origins: &#39;*:*&#39;&#125;).listen(this.server);</span><br><span class="line">        io.on(&#39;connection&#39;, this.sktool.socketConnect);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在其它地方，可以如下使用：const &#123;SocketUtil&#125; &#x3D; require(&quot;.&#x2F;SocketUse.class&quot;)</span><br><span class="line">module.exports &#x3D; &#123;SocketUtil, SocketDispatcher&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h5 id="然后在web服务开始的地方，如index-js文件或app-js文件中"><a href="#然后在web服务开始的地方，如index-js文件或app-js文件中" class="headerlink" title="然后在web服务开始的地方，如index.js文件或app.js文件中"></a>然后在web服务开始的地方，如index.js文件或app.js文件中</h5><p>如server.listen(this.port)之后，加上如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const useWebSocket &#x3D; true</span><br><span class="line">if(useWebSocket) &#123;</span><br><span class="line">    const &#123;SocketUtil&#125; &#x3D; require(&quot;.&#x2F;SocketUse.class&quot;)</span><br><span class="line">    let config &#x3D; require(&quot;..&#x2F;config&#x2F;soccer.config&quot;)</span><br><span class="line">    const socket &#x3D; new SocketUtil(server)</span><br><span class="line">    socket.connect()</span><br><span class="line">    config.SocketTool.Instance &#x3D; socket.SocketTool</span><br><span class="line">    logger.info(&#96;start websoket on port:$&#123;this.port&#125;&#96;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>编写websocket.ts文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Injectable &#125; from &#39;@angular&#x2F;core&#39;;</span><br><span class="line">import &#123;interval, Subject,Observable&#125; from &#39;rxjs&#39;;</span><br><span class="line">&#x2F;&#x2F;import &#123; Observable &#125; from &#39;rxjs&#x2F;Observable&#39;;</span><br><span class="line">import * as io from &#39;socket.io-client&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;*</span><br><span class="line">使用socket.io-client，构建后在浏览器调试窗口中可发现异常：</span><br><span class="line">Global is not defined</span><br><span class="line">这时候可在polyfills.ts文件中加入：</span><br><span class="line">(window as any).global &#x3D; window</span><br><span class="line">即可。（任何位置都行）</span><br><span class="line">As already mentioned in comment, add the above code in the polyfills.ts file.</span><br><span class="line"> *&#x2F;</span><br><span class="line">@Injectable(&#123;</span><br><span class="line">  providedIn: &#39;root&#39;</span><br><span class="line">&#125;)</span><br><span class="line">export class WebsocketService &#123;</span><br><span class="line">	private url &#x3D; &#39;http:&#x2F;&#x2F;192.168.3.158:6002&#39;; </span><br><span class="line">	private socket;</span><br><span class="line">	public messageSubject;</span><br><span class="line">	private webSocket:any;</span><br><span class="line">  	connectSuccess &#x3D; false;                         &#x2F;&#x2F; websocket 连接成功</span><br><span class="line">  	period &#x3D; 60 * 1000 * 10;                        &#x2F;&#x2F; 10分钟检查一次</span><br><span class="line">	serverTimeoutSubscription &#x3D; null;               &#x2F;&#x2F; 定时检测连接对象</span><br><span class="line">  	reconnectFlag &#x3D; false;                          &#x2F;&#x2F; 重连</span><br><span class="line">  	reconnectPeriod &#x3D; 5 * 1000;                     &#x2F;&#x2F; 重连失败,则5秒钟重连一次</span><br><span class="line">  	reconnectSubscription &#x3D; null;                   &#x2F;&#x2F; 重连订阅对象</span><br><span class="line">  	runTimeSubscription;                            &#x2F;&#x2F; 记录运行连接subscription</span><br><span class="line">  	runTimePeriod &#x3D; 60 * 10000;                     &#x2F;&#x2F; 记录运行连接时间</span><br><span class="line"></span><br><span class="line">	constructor()&#123;</span><br><span class="line">		this.messageSubject &#x3D; new Subject();</span><br><span class="line">		console.log(&#96;【 WebsocketService 】 constructor.................&#96;)</span><br><span class="line"></span><br><span class="line">		this.connect(this.url)</span><br><span class="line">	&#125;</span><br><span class="line">	connect(url) &#123;</span><br><span class="line">	    if (!!url) &#123;</span><br><span class="line">	      this.url &#x3D; url;</span><br><span class="line">	    &#125;</span><br><span class="line">	    &#x2F;&#x2F; 创建websocket对象</span><br><span class="line">	    this.createWebSocket();</span><br><span class="line">	&#125;	</span><br><span class="line">	sendMessage(act,message)&#123;</span><br><span class="line">	  	this.webSocket.emit(act, message);  </span><br><span class="line">	&#125;</span><br><span class="line">	createWebSocket() &#123;</span><br><span class="line">		console.log(&#96;【 WebsocketService 】 start connect to &#x3D;&#x3D;&gt; $&#123;this.url&#125;&#96;)</span><br><span class="line">	    &#x2F;&#x2F; 如果没有建立过连接，才建立连接并且添加时间监听</span><br><span class="line">	    this.webSocket &#x3D; io(this.url); &#x2F;&#x2F; new WebSocket(this.url);</span><br><span class="line">	   	this.webSocket.on(&#39;welcome&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">	    	this.onMessage(data)</span><br><span class="line">	   	&#125;);	   </span><br><span class="line">	   	this.webSocket.on(&#39;svcMsg&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">	    	this.onSvcMsg(data)</span><br><span class="line">	   	&#125;);	  </span><br><span class="line">	    &#x2F;&#x2F; 建立连接成功</span><br><span class="line">	    &#x2F;&#x2F;this.webSocket.onopen &#x3D; (e) &#x3D;&gt; this.onOpen(e);</span><br><span class="line">	    &#x2F;&#x2F; 接收到消息</span><br><span class="line">	    this.webSocket.onmessage &#x3D; (e) &#x3D;&gt; this.onMessage(e);</span><br><span class="line">	    &#x2F;&#x2F; 连接关闭</span><br><span class="line">	    &#x2F;&#x2F;this.webSocket.onclose &#x3D; (e) &#x3D;&gt; this.onClose(e);</span><br><span class="line">	    &#x2F;&#x2F; 异常</span><br><span class="line">	    &#x2F;&#x2F;this.webSocket.onerror &#x3D; (e) &#x3D;&gt; this.onError(e);</span><br><span class="line">	&#125;	  </span><br><span class="line">	getMessages() &#123;</span><br><span class="line">	  	let observable &#x3D; new Observable(observer &#x3D;&gt; &#123;</span><br><span class="line">		   	this.socket &#x3D; io(this.url);</span><br><span class="line">		   	this.socket.on(&#39;welcome&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">		    	observer.next(data);  </span><br><span class="line">		   	&#125;);</span><br><span class="line">		   	this.socket.on(&#39;svcMsg&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">		    	observer.next(data);  </span><br><span class="line">		   	&#125;);</span><br><span class="line">		   	return () &#x3D;&gt; &#123;</span><br><span class="line">		    	this.socket.disconnect();</span><br><span class="line">		   	&#125;; </span><br><span class="line">	  	&#125;)   </span><br><span class="line">	  	return observable;</span><br><span class="line">	&#125; </span><br><span class="line">	getMessages2() &#123;</span><br><span class="line">	  	let observable &#x3D; new Observable(observer &#x3D;&gt; &#123;</span><br><span class="line">		   	this.socket &#x3D; io(this.url);</span><br><span class="line">		   	this.socket.on(&#39;welcome&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">		    	observer.next(data);  </span><br><span class="line">		   	&#125;);</span><br><span class="line">		   	this.socket.on(&#39;svcMsg&#39;, (data) &#x3D;&gt; &#123;</span><br><span class="line">		    	observer.next(data);  </span><br><span class="line">		   	&#125;);</span><br><span class="line">		   	return () &#x3D;&gt; &#123;</span><br><span class="line">		    	this.socket.disconnect();</span><br><span class="line">		   	&#125;; </span><br><span class="line">	  	&#125;)   </span><br><span class="line">	  	return observable;</span><br><span class="line">	&#125; 	</span><br><span class="line">	onOpen(e) &#123;</span><br><span class="line">	    console.log(&#39;websocket 已连接&#39;);</span><br><span class="line">	    &#x2F;&#x2F; 设置连接成功</span><br><span class="line">	    this.connectSuccess &#x3D; true;</span><br><span class="line">	    &#x2F;&#x2F; 如果是重连中</span><br><span class="line">	    if (this.reconnectFlag) &#123;</span><br><span class="line">	      &#x2F;&#x2F; 1.停止重连</span><br><span class="line">	      this.stopReconnect();</span><br><span class="line">	      &#x2F;&#x2F; 2.重新开启心跳</span><br><span class="line">	      this.heartCheckStart();</span><br><span class="line">	      &#x2F;&#x2F; 3.重新开始计算运行时间</span><br><span class="line">	      this.calcRunTime();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	onMessage(data) &#123;</span><br><span class="line">	    console.log(&#39;&#x3D;&#x3D;&#x3D;&#x3D;RCV:[WebsocketService]&#39;, data);</span><br><span class="line">	    &#x2F;&#x2F; 将接受到的消息发布出去</span><br><span class="line">	    &#x2F;&#x2F;const message &#x3D; JSON.parse(data);</span><br><span class="line">	    &#x2F;&#x2F;console.log(&#39;接收到消息时间&#39;, new Date().getTime());</span><br><span class="line">	    this.messageSubject.next(data);</span><br><span class="line">	&#125;</span><br><span class="line">	onSvcMsg(data) &#123;</span><br><span class="line">	    console.log(&#39;接收到的消息&#39;, data);</span><br><span class="line">	    &#x2F;&#x2F; 将接受到的消息发布出去</span><br><span class="line">	    &#x2F;&#x2F;const message &#x3D; JSON.parse(data);</span><br><span class="line">	    &#x2F;&#x2F;console.log(&#39;接收到消息时间&#39;, new Date().getTime());</span><br><span class="line">	    this.messageSubject.next(data);</span><br><span class="line">	&#125;	</span><br><span class="line">	private onClose(e) &#123;</span><br><span class="line">	    console.log(&#39;连接关闭&#39;, e);</span><br><span class="line">	    this.connectSuccess &#x3D; false;</span><br><span class="line">	    this.webSocket.close();</span><br><span class="line">	    &#x2F;&#x2F; 关闭时开始重连</span><br><span class="line">	    this.reconnect();</span><br><span class="line">	    this.stopRunTime();</span><br><span class="line">	    &#x2F;&#x2F; throw new Error(&#39;webSocket connection closed:)&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">	private onError(e) &#123;</span><br><span class="line">	    &#x2F;&#x2F; 出现异常时一定会进onClose,所以只在onClose做一次重连动作</span><br><span class="line">	    console.log(&#39;连接异常&#39;, e);</span><br><span class="line">	    this.connectSuccess &#x3D; false;</span><br><span class="line">	    &#x2F;&#x2F; throw new Error(&#39;webSocket connection error:)&#39;);</span><br><span class="line">	&#125;	</span><br><span class="line"></span><br><span class="line">	reconnect() &#123;</span><br><span class="line">	    &#x2F;&#x2F; 如果已重连,则直接return,避免重复连接</span><br><span class="line">	    if (this.connectSuccess) &#123;</span><br><span class="line">	      this.stopReconnect();</span><br><span class="line">	      console.log(&#39;已经连接成功,停止重连&#39;);</span><br><span class="line">	      return;</span><br><span class="line">	    &#125;</span><br><span class="line">	    &#x2F;&#x2F; 如果正在连接中,则直接return,避免产生多个轮训事件</span><br><span class="line">	    if (this.reconnectFlag) &#123;</span><br><span class="line">	      console.log(&#39;正在重连,直接返回&#39;);</span><br><span class="line">	      return;</span><br><span class="line">	    &#125;</span><br><span class="line">	    &#x2F;&#x2F; 开始重连</span><br><span class="line">	    this.reconnectFlag &#x3D; true;</span><br><span class="line">	    &#x2F;&#x2F; 如果没能成功连接,则定时重连</span><br><span class="line">	    this.reconnectSubscription &#x3D; interval(this.reconnectPeriod).subscribe(async (val) &#x3D;&gt; &#123;</span><br><span class="line">	      console.log(&#96;重连:$&#123;val&#125;次&#96;);</span><br><span class="line">	      const url &#x3D; this.url;</span><br><span class="line">	      &#x2F;&#x2F; 重新连接</span><br><span class="line">	      this.connect(url);</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	stopReconnect() &#123;</span><br><span class="line">	    &#x2F;&#x2F; 连接标识置为false</span><br><span class="line">	    this.reconnectFlag &#x3D; false;</span><br><span class="line">	    &#x2F;&#x2F; 取消订阅</span><br><span class="line">	    if (typeof this.reconnectSubscription !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; this.reconnectSubscription !&#x3D; null) &#123;</span><br><span class="line">	      this.reconnectSubscription.unsubscribe();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heartCheckStart() &#123;</span><br><span class="line">	    this.serverTimeoutSubscription &#x3D; interval(this.period).subscribe((val) &#x3D;&gt; &#123;</span><br><span class="line">	      &#x2F;&#x2F; 保持连接状态,重置下</span><br><span class="line">	      if (this.webSocket !&#x3D; null &amp;&amp; this.webSocket.readyState &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">	        console.log(val, &#39;连接状态，发送消息保持连接&#39;);</span><br><span class="line">	      &#125; else &#123;</span><br><span class="line">	        &#x2F;&#x2F; 停止心跳</span><br><span class="line">	        this.heartCheckStop();</span><br><span class="line">	        &#x2F;&#x2F; 开始重连</span><br><span class="line">	        this.reconnect();</span><br><span class="line">	        console.log(&#39;连接已断开,重新连接&#39;);</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;);</span><br><span class="line">	  &#125;</span><br><span class="line">	heartCheckStop() &#123;</span><br><span class="line">	    &#x2F;&#x2F; 取消订阅停止心跳</span><br><span class="line">	    if (typeof this.serverTimeoutSubscription !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; this.serverTimeoutSubscription !&#x3D; null) &#123;</span><br><span class="line">	      this.serverTimeoutSubscription.unsubscribe();</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">  	calcRunTime() &#123;</span><br><span class="line">	    this.runTimeSubscription &#x3D; interval(this.runTimePeriod).subscribe(period &#x3D;&gt; &#123;</span><br><span class="line">	      console.log(&#39;运行时间&#39;, &#96;$&#123;period&#125;分钟&#96;);</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	stopRunTime() &#123;</span><br><span class="line">	    if (typeof this.runTimeSubscription !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; this.runTimeSubscription !&#x3D;&#x3D; null) &#123;</span><br><span class="line">	      this.runTimeSubscription.unsubscribe();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	&#x2F;*</span><br><span class="line">	messageSubject;                                 &#x2F;&#x2F; subject对象,用于发送事件</span><br><span class="line">  	private url;                                    &#x2F;&#x2F; 默认请求的url</span><br><span class="line">  	private webSocket: WebSocket;                   &#x2F;&#x2F; websocket对象</span><br><span class="line">  	connectSuccess &#x3D; false;                         &#x2F;&#x2F; websocket 连接成功</span><br><span class="line">  	period &#x3D; 60 * 1000 * 10;                        &#x2F;&#x2F; 10分钟检查一次</span><br><span class="line">	serverTimeoutSubscription &#x3D; null;               &#x2F;&#x2F; 定时检测连接对象</span><br><span class="line">  	reconnectFlag &#x3D; false;                          &#x2F;&#x2F; 重连</span><br><span class="line">  	reconnectPeriod &#x3D; 5 * 1000;                     &#x2F;&#x2F; 重连失败,则5秒钟重连一次</span><br><span class="line">  	reconnectSubscription &#x3D; null;                   &#x2F;&#x2F; 重连订阅对象</span><br><span class="line">  	runTimeSubscription;                            &#x2F;&#x2F; 记录运行连接subscription</span><br><span class="line">  	runTimePeriod &#x3D; 60 * 10000;                     &#x2F;&#x2F; 记录运行连接时间</span><br><span class="line"></span><br><span class="line">  	constructor() &#123; </span><br><span class="line">		this.messageSubject &#x3D; new Subject();</span><br><span class="line">	    console.log(&#39;开始心跳检测&#39;);</span><br><span class="line">	    &#x2F;&#x2F; 进入程序就进行心跳检测,避免出现开始就连接中断,后续不重连</span><br><span class="line">	    this.heartCheckStart();</span><br><span class="line">	    this.calcRunTime();</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">  	sendMessage(message) &#123;</span><br><span class="line">	    this.webSocket.send(message);</span><br><span class="line">	&#125;</span><br><span class="line">	connect(url) &#123;</span><br><span class="line">	    if (!!url) &#123;</span><br><span class="line">	      this.url &#x3D; url;</span><br><span class="line">	    &#125;</span><br><span class="line">	    &#x2F;&#x2F; 创建websocket对象</span><br><span class="line">	    this.createWebSocket();</span><br><span class="line">	&#125;</span><br><span class="line">	createWebSocket() &#123;</span><br><span class="line">		console.log(&#96;connect to &#x3D;&#x3D;&gt; $&#123;this.url&#125;&#96;)</span><br><span class="line">	    &#x2F;&#x2F; 如果没有建立过连接，才建立连接并且添加时间监听</span><br><span class="line">	    this.webSocket &#x3D; new WebSocket(this.url);</span><br><span class="line">	    &#x2F;&#x2F; 建立连接成功</span><br><span class="line">	    this.webSocket.onopen &#x3D; (e) &#x3D;&gt; this.onOpen(e);</span><br><span class="line">	    &#x2F;&#x2F; 接收到消息</span><br><span class="line">	    this.webSocket.onmessage &#x3D; (e) &#x3D;&gt; this.onMessage(e);</span><br><span class="line">	    &#x2F;&#x2F; 连接关闭</span><br><span class="line">	    this.webSocket.onclose &#x3D; (e) &#x3D;&gt; this.onClose(e);</span><br><span class="line">	    &#x2F;&#x2F; 异常</span><br><span class="line">	    this.webSocket.onerror &#x3D; (e) &#x3D;&gt; this.onError(e);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	onOpen(e) &#123;</span><br><span class="line">	    console.log(&#39;websocket 已连接&#39;);</span><br><span class="line">	    &#x2F;&#x2F; 设置连接成功</span><br><span class="line">	    this.connectSuccess &#x3D; true;</span><br><span class="line">	    &#x2F;&#x2F; 如果是重连中</span><br><span class="line">	    if (this.reconnectFlag) &#123;</span><br><span class="line">	      &#x2F;&#x2F; 1.停止重连</span><br><span class="line">	      this.stopReconnect();</span><br><span class="line">	      &#x2F;&#x2F; 2.重新开启心跳</span><br><span class="line">	      this.heartCheckStart();</span><br><span class="line">	      &#x2F;&#x2F; 3.重新开始计算运行时间</span><br><span class="line">	      this.calcRunTime();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	onMessage(event) &#123;</span><br><span class="line">	    console.log(&#39;接收到的消息&#39;, event.data);</span><br><span class="line">	    &#x2F;&#x2F; 将接受到的消息发布出去</span><br><span class="line">	    const message &#x3D; JSON.parse(event.data);</span><br><span class="line">	    console.log(&#39;接收到消息时间&#39;, new Date().getTime());</span><br><span class="line">	    this.messageSubject.next(message);</span><br><span class="line">	&#125;</span><br><span class="line">	private onClose(e) &#123;</span><br><span class="line">	    console.log(&#39;连接关闭&#39;, e);</span><br><span class="line">	    this.connectSuccess &#x3D; false;</span><br><span class="line">	    this.webSocket.close();</span><br><span class="line">	    &#x2F;&#x2F; 关闭时开始重连</span><br><span class="line">	    this.reconnect();</span><br><span class="line">	    this.stopRunTime();</span><br><span class="line">	    &#x2F;&#x2F; throw new Error(&#39;webSocket connection closed:)&#39;);</span><br><span class="line">	&#125;</span><br><span class="line">	private onError(e) &#123;</span><br><span class="line">	    &#x2F;&#x2F; 出现异常时一定会进onClose,所以只在onClose做一次重连动作</span><br><span class="line">	    console.log(&#39;连接异常&#39;, e);</span><br><span class="line">	    this.connectSuccess &#x3D; false;</span><br><span class="line">	    &#x2F;&#x2F; throw new Error(&#39;webSocket connection error:)&#39;);</span><br><span class="line">	&#125;	</span><br><span class="line">	reconnect() &#123;</span><br><span class="line">	    &#x2F;&#x2F; 如果已重连,则直接return,避免重复连接</span><br><span class="line">	    if (this.connectSuccess) &#123;</span><br><span class="line">	      this.stopReconnect();</span><br><span class="line">	      console.log(&#39;已经连接成功,停止重连&#39;);</span><br><span class="line">	      return;</span><br><span class="line">	    &#125;</span><br><span class="line">	    &#x2F;&#x2F; 如果正在连接中,则直接return,避免产生多个轮训事件</span><br><span class="line">	    if (this.reconnectFlag) &#123;</span><br><span class="line">	      console.log(&#39;正在重连,直接返回&#39;);</span><br><span class="line">	      return;</span><br><span class="line">	    &#125;</span><br><span class="line">	    &#x2F;&#x2F; 开始重连</span><br><span class="line">	    this.reconnectFlag &#x3D; true;</span><br><span class="line">	    &#x2F;&#x2F; 如果没能成功连接,则定时重连</span><br><span class="line">	    this.reconnectSubscription &#x3D; interval(this.reconnectPeriod).subscribe(async (val) &#x3D;&gt; &#123;</span><br><span class="line">	      console.log(&#96;重连:$&#123;val&#125;次&#96;);</span><br><span class="line">	      const url &#x3D; this.url;</span><br><span class="line">	      &#x2F;&#x2F; 重新连接</span><br><span class="line">	      this.connect(url);</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	stopReconnect() &#123;</span><br><span class="line">	    &#x2F;&#x2F; 连接标识置为false</span><br><span class="line">	    this.reconnectFlag &#x3D; false;</span><br><span class="line">	    &#x2F;&#x2F; 取消订阅</span><br><span class="line">	    if (typeof this.reconnectSubscription !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; this.reconnectSubscription !&#x3D; null) &#123;</span><br><span class="line">	      this.reconnectSubscription.unsubscribe();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	heartCheckStart() &#123;</span><br><span class="line">	    this.serverTimeoutSubscription &#x3D; interval(this.period).subscribe((val) &#x3D;&gt; &#123;</span><br><span class="line">	      &#x2F;&#x2F; 保持连接状态,重置下</span><br><span class="line">	      if (this.webSocket !&#x3D; null &amp;&amp; this.webSocket.readyState &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class="line">	        console.log(val, &#39;连接状态，发送消息保持连接&#39;);</span><br><span class="line">	      &#125; else &#123;</span><br><span class="line">	        &#x2F;&#x2F; 停止心跳</span><br><span class="line">	        this.heartCheckStop();</span><br><span class="line">	        &#x2F;&#x2F; 开始重连</span><br><span class="line">	        this.reconnect();</span><br><span class="line">	        console.log(&#39;连接已断开,重新连接&#39;);</span><br><span class="line">	      &#125;</span><br><span class="line">	    &#125;);</span><br><span class="line">	  &#125;</span><br><span class="line">	heartCheckStop() &#123;</span><br><span class="line">	    &#x2F;&#x2F; 取消订阅停止心跳</span><br><span class="line">	    if (typeof this.serverTimeoutSubscription !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; this.serverTimeoutSubscription !&#x3D; null) &#123;</span><br><span class="line">	      this.serverTimeoutSubscription.unsubscribe();</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">  	calcRunTime() &#123;</span><br><span class="line">	    this.runTimeSubscription &#x3D; interval(this.runTimePeriod).subscribe(period &#x3D;&gt; &#123;</span><br><span class="line">	      console.log(&#39;运行时间&#39;, &#96;$&#123;period&#125;分钟&#96;);</span><br><span class="line">	    &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">	stopRunTime() &#123;</span><br><span class="line">	    if (typeof this.runTimeSubscription !&#x3D;&#x3D; &#39;undefined&#39; &amp;&amp; this.runTimeSubscription !&#x3D;&#x3D; null) &#123;</span><br><span class="line">	      this.runTimeSubscription.unsubscribe();</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在需要使用websocket的页面中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">constructor(</span><br><span class="line">  	private webSocket:WebsocketService,</span><br><span class="line">  	public DSS: DataCenterService,</span><br><span class="line">  	private tools:AppToolsService,</span><br><span class="line">  	private ngZone: NgZone,private route: ActivatedRoute) &#123;</span><br><span class="line">  	&#125;</span><br><span class="line"></span><br><span class="line">ngOnInit(): void &#123;</span><br><span class="line">    let li &#x3D; &#123;roleId:1,userName:this.DSS.loginId&#125;</span><br><span class="line">    console.log(li)</span><br><span class="line">    this.webSocket.sendMessage(&#39;CurrentRoleID&#39;,li)  </span><br><span class="line">    &#x2F;&#x2F;订阅webSocket接收到的消息</span><br><span class="line">    this.webSocket.messageSubject.subscribe(</span><br><span class="line">        data &#x3D;&gt; &#123;</span><br><span class="line">            if (data.type) &#123;</span><br><span class="line">                this.TreatSvrMessage(data)</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                &#x2F;&#x2F; 其它信息，如欢迎等测试消息</span><br><span class="line">                console.log(&#96;&#x3D;&#x3D;&#x3D;&#x3D;RCV:[OrganizationListComponent]$&#123;data&#125;&#96;)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        err &#x3D;&gt; &#123;console.log(err)&#125;,</span><br><span class="line">        () &#x3D;&gt; &#123;console.log(&#39;completed...&#39;)&#125;</span><br><span class="line">    );  </span><br><span class="line">&#125;</span><br><span class="line">TreatSvrMessage(svrDatas)&#123;</span><br><span class="line">    console.log(svrDatas)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NodeJS</category>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>在Nodejs中使用微服务Moleculer</title>
    <url>/2021/02/05/%E5%9C%A8Nodejs%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%BE%AE%E6%9C%8D%E5%8A%A1Moleculer/</url>
    <content><![CDATA[<p>在NodeJS中使用molecular微服务框架。</p>
<p>有段时间没用molecular，感觉忘了。记录一下，以便将来再用时能迅速拿起来。只记录了简单的快速上手。</p>
<h3 id="1-项目环境"><a href="#1-项目环境" class="headerlink" title="1.项目环境"></a>1.项目环境</h3><p>一个web服务为网站提供数据请求，一个数据服务提供后台数据接收与处理服务。数据服务接收到数据之后通过微服务连接到web服务，由web服务通过websocket推送到客户端。<br>微服务使用redis作为数据交换。</p>
<a id="more"></a>
<h3 id="2-安装moleculer"><a href="#2-安装moleculer" class="headerlink" title="2.安装moleculer"></a>2.安装moleculer</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install moleculer</span><br></pre></td></tr></table></figure>
<h3 id="3-创建微服务定义文件-microservice-webExtended-service-js"><a href="#3-创建微服务定义文件-microservice-webExtended-service-js" class="headerlink" title="3.创建微服务定义文件:microservice/webExtended.service.js"></a>3.创建微服务定义文件:microservice/webExtended.service.js</h3><p>在配置文件soccer.config.js中添加配置:  </p>
<h5 id="如果使用redis"><a href="#如果使用redis" class="headerlink" title="如果使用redis"></a>如果使用redis</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transporter_nats: &quot;redis:&#x2F;&#x2F;localhost:6379&quot;,</span><br></pre></td></tr></table></figure>
<h5 id="如果使用TCP-tcp有消息大小限制"><a href="#如果使用TCP-tcp有消息大小限制" class="headerlink" title="如果使用TCP(tcp有消息大小限制)"></a>如果使用TCP(tcp有消息大小限制)</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transporter_nats: &quot;TCP&quot;,</span><br></pre></td></tr></table></figure>
<p>更多配置请参考：<a href="https://moleculer.services/">https://moleculer.services</a>  </p>
<h4 id="创建微服务定义文件-webExtended-service-js"><a href="#创建微服务定义文件-webExtended-service-js" class="headerlink" title="创建微服务定义文件:webExtended.service.js"></a>创建微服务定义文件:webExtended.service.js</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const log4js &#x3D; require(&#39;..&#x2F;tools&#x2F;log-config&#39;)</span><br><span class="line">const logger &#x3D; log4js.getLogger()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;网站提供微服务，供其它微服务调用。</span><br><span class="line">const config &#x3D; require(&quot;..&#x2F;config&#x2F;soccer.config&quot;)</span><br><span class="line">module.exports&#x3D;&#123;</span><br><span class="line">    name:&quot;webExtended&quot;,</span><br><span class="line">    actions:&#123;</span><br><span class="line">        newSZZS(datas)&#123;</span><br><span class="line">            logger.info(&#96;new SZZS is arrived...&#96;)</span><br><span class="line">            let pars &#x3D; datas.params</span><br><span class="line">            logger.info(pars)</span><br><span class="line">            if(config.SocketTool.Instance!&#x3D;null) &#123;</span><br><span class="line">                config.SocketTool.Instance.SocketSend(pars)</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;,</span><br><span class="line">        test(msg)&#123;</span><br><span class="line">            return &quot;hello &quot; + (msg.params.message || &quot;,how are you,webExtended svc is running....&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    created()&#123;</span><br><span class="line">        logger.info(&#39;webExtended service created...&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="4-创建微服务启动模块-microservice-start-webextended-service-js"><a href="#4-创建微服务启动模块-microservice-start-webextended-service-js" class="headerlink" title="4.创建微服务启动模块:microservice/start_webextended_service.js"></a>4.创建微服务启动模块:microservice/start_webextended_service.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const log4js &#x3D; require(&#39;..&#x2F;tools&#x2F;log-config&#39;)</span><br><span class="line">const logger &#x3D; log4js.getLogger()</span><br><span class="line"></span><br><span class="line">const broker &#x3D; null</span><br><span class="line">const &#123;ServiceBroker&#125;&#x3D;require(&#39;moleculer&#39;)</span><br><span class="line">const config &#x3D; require(&quot;..&#x2F;config&#x2F;soccer.config&quot;)</span><br><span class="line"></span><br><span class="line">let tt &#x3D; &#123;</span><br><span class="line">	start()&#123;</span><br><span class="line">        let broker &#x3D; new ServiceBroker(&#123;</span><br><span class="line">            namespace:&#39;soccer&#39;,</span><br><span class="line">            nodeID:&#39;webextended-service&#39;,</span><br><span class="line">            transporter:config.service.transporter_nats</span><br><span class="line">        &#125;)</span><br><span class="line">        broker.loadService(&quot;..&#x2F;microservice&#x2F;webExtended.service.js&quot;)</span><br><span class="line">        broker.start().then(()&#x3D;&gt;&#123;</span><br><span class="line">            logger.info(&#96;moleculer micro service :webextended start....&#96;)</span><br><span class="line">        &#125;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; tt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="5-创建微服务连接模块-microservice-start-webextended-connector-js"><a href="#5-创建微服务连接模块-microservice-start-webextended-connector-js" class="headerlink" title="5.创建微服务连接模块:microservice/start_webextended_connector.js"></a>5.创建微服务连接模块:microservice/start_webextended_connector.js</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const log4js &#x3D; require(&#39;..&#x2F;tools&#x2F;log-config&#39;)</span><br><span class="line">const logger &#x3D; log4js.getLogger()</span><br><span class="line">const config &#x3D; require(&quot;..&#x2F;config&#x2F;soccer.config&quot;)</span><br><span class="line">&#x2F;&#x2F;并非启动服务，此模块实际上是根据配置启动连接到WEB服务的broker</span><br><span class="line"></span><br><span class="line">let connect2Server &#x3D; function () &#123;</span><br><span class="line">    logger.info(&#96;try to connecting webExtended server....&#96;)</span><br><span class="line">    return broker.waitForServices(&quot;webExtended&quot;, 10 * 1000, 500)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let send2Webextened2 &#x3D; function (dds) &#123;</span><br><span class="line">    logger.info(&#96;call webExtended.newSZZS&#96;)</span><br><span class="line">    broker.call(&quot;webExtended.newSZZS&quot;, &#123;data: dds&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let broker &#x3D; null</span><br><span class="line">let webExtendedIsReady &#x3D; false</span><br><span class="line">let tt &#x3D; &#123;</span><br><span class="line">    start() &#123;</span><br><span class="line">        const &#123;ServiceBroker&#125; &#x3D; require(&#39;moleculer&#39;)</span><br><span class="line"></span><br><span class="line">        broker &#x3D; new ServiceBroker(&#123;</span><br><span class="line">            namespace: &#39;soccer&#39;,</span><br><span class="line">            nodeID: &quot;soccer-web-connector-broker&quot;,</span><br><span class="line">            transporter: config.service.transporter_nats</span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        broker.start()</span><br><span class="line">    &#125;,</span><br><span class="line">    async TEST(ctx, next) &#123;</span><br><span class="line">        logger.error(&#39;test webExtended.service.....&#39;)</span><br><span class="line">        let ans &#x3D; await broker.call(&quot;webExtended.test&quot;, &#123;message: &#39;china-webExtended&#39;&#125;)</span><br><span class="line">        logger.info(ans)</span><br><span class="line">        ctx.body &#x3D; ans</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    Send2Webextended(dataFlag, dataInfo) &#123;</span><br><span class="line">        logger.info(&#96;【webExtended Connector】:send to client....&#96;)</span><br><span class="line">        if (webExtendedIsReady &#x3D;&#x3D; false) &#123;</span><br><span class="line">            connect2Server()</span><br><span class="line">                .then(() &#x3D;&gt; &#123;</span><br><span class="line">                    webExtendedIsReady &#x3D; true</span><br><span class="line">                    send2Webextened2(dataInfo)</span><br><span class="line">                &#125;)</span><br><span class="line">                .catch(err &#x3D;&gt; &#123;</span><br><span class="line">                    logger.error(&#96;webExtended service is not ready .....&#96;)</span><br><span class="line">                    logger.info(err)</span><br><span class="line">                &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            send2Webextened2(dataInfo)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports &#x3D; tt</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-在web服务开始后启动微服务。如index-js中"><a href="#6-在web服务开始后启动微服务。如index-js中" class="headerlink" title="6.在web服务开始后启动微服务。如index.js中"></a>6.在web服务开始后启动微服务。如index.js中</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let webExtended &#x3D; require(&quot;..&#x2F;microservice&#x2F;start_webextended_service&quot;)</span><br><span class="line">webExtended.start()</span><br><span class="line">logger.info(&#96;web microservice started&#96;)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在需要使用web微服务的文件中：  </p>
<h3 id="7-在数据服务中连接web提供的微服务"><a href="#7-在数据服务中连接web提供的微服务" class="headerlink" title="7.在数据服务中连接web提供的微服务"></a>7.在数据服务中连接web提供的微服务</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">logger.error(&#96;FundService start connect webExtend &#96;)</span><br><span class="line">let webExtend &#x3D; require(&quot;..&#x2F;microservice&#x2F;start_webextended_connector&quot;)</span><br><span class="line">&#x2F;&#x2F;连接微服务</span><br><span class="line">webExtend.start()</span><br></pre></td></tr></table></figure>
<h3 id="8-在数据服务中调用web微服务提供的服务方法"><a href="#8-在数据服务中调用web微服务提供的服务方法" class="headerlink" title="8.在数据服务中调用web微服务提供的服务方法"></a>8.在数据服务中调用web微服务提供的服务方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">webExtend.Send2Webextended(&#39;szzs-real&#39;,res)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>NodeJS</category>
      </categories>
      <tags>
        <tag>NodeJS</tag>
      </tags>
  </entry>
  <entry>
    <title>IT人应在从业5年内确定自己的职场规划</title>
    <url>/2021/02/04/IT%E4%BA%BA%E5%BA%94%E5%9C%A8%E4%BB%8E%E4%B8%9A5%E5%B9%B4%E5%86%85%E7%A1%AE%E5%AE%9A%E8%87%AA%E5%B7%B1%E7%9A%84%E8%81%8C%E5%9C%BA%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>IT技术就那么几年，早点为将来做准备吧！  </p>
]]></content>
      <categories>
        <category>杂谈</category>
      </categories>
      <tags>
        <tag>杂谈</tag>
      </tags>
  </entry>
  <entry>
    <title>Angular通用开发模板</title>
    <url>/2021/01/31/Angular%E9%80%9A%E7%94%A8%E5%BC%80%E5%8F%91%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<h2 id="AngularGeneral"><a href="#AngularGeneral" class="headerlink" title="AngularGeneral"></a>AngularGeneral</h2><p>想做一个比较通用的angular应用模板？为自己的以后项目做一个框架。暂时有如下特性：</p>
<a id="more"></a>

<h3 id="一、多路由"><a href="#一、多路由" class="headerlink" title="一、多路由"></a>一、多路由</h3><p>应用中各个不同的业务功能可以有自己不同的布局模板。  </p>
<ol>
<li>登录，错误处理有着自己的路由，自己的布局。  </li>
<li>例子中的基金有自己的路由，自己的布局模板。  </li>
<li>例子中的足球有自己的路由和自己的布局模板。<br>等等。</li>
</ol>
<h3 id="二、实现了懒加载"><a href="#二、实现了懒加载" class="headerlink" title="二、实现了懒加载"></a>二、实现了懒加载</h3><p>基于业务功能的子路由实现了懒加载<br>懒加载的路由也能动态加入到菜单中。（见后面的实现方法）  </p>
<h3 id="三、基于业务功能创建模块"><a href="#三、基于业务功能创建模块" class="headerlink" title="三、基于业务功能创建模块"></a>三、基于业务功能创建模块</h3><p>假如我们的项目中包括订单，用户，商品，足球，基金<br>基于业务功能创建模块，  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ng g m soccer --routing  </span><br><span class="line">ng g m fund --routing  </span><br><span class="line">ng g m user --routing  </span><br><span class="line">ng g m order --routing  </span><br></pre></td></tr></table></figure>
<p>–routing //表示创建的模块带路由，用于懒加载  </p>
<p>创建结束之后<br>我们在app目录下就可以发现如下目录<br>soccer<br>user<br>order<br>fund<br>…<br>等目录<br>现在假设我的足球模块中包括页面联赛，球队，分析等页面,我们可以如下创建页面组件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ng g c soccer&#x2F;leagues  </span><br><span class="line">ng g c soccer&#x2F;teams  </span><br><span class="line">ng g c soccer&#x2F;analysis  </span><br></pre></td></tr></table></figure>
<p>创建结束之后<br>我们在soccer目录下就可以发现如下目录<br>leagues<br>teams<br>analysis<br>…<br>等目录，每个目录都包括该页面所需要的一系列文件。  </p>
<h3 id="四、多级路由生成"><a href="#四、多级路由生成" class="headerlink" title="四、多级路由生成"></a>四、多级路由生成</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ng g c soccerLayout --module&#x3D;app.module  </span><br></pre></td></tr></table></figure>
<p>如上生成基于业务功能应用的布局组件。<br>注意，所有的布局组件都应加入到app.module.ts模块中。  </p>
<p>修改根下的app.component.ts仅保留</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;router-outlet&gt;&lt;&#x2F;router-outlet&gt;</span><br></pre></td></tr></table></figure>
<p>部分。  </p>
<p>即直接展示子路由组件内容。如登录页等。 </p>
<p>例如：根路由文件下的如下路由部分  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    path: &#39;login&#39;,  </span><br><span class="line">    pathMatch: &#39;full&#39;,  </span><br><span class="line">    component:LoginComponent,  </span><br><span class="line">    data: &#123;  </span><br><span class="line">        breadcrumb: &#39;登录&#39;,  </span><br><span class="line">        visible: false  </span><br><span class="line">    &#125;,  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure>
<p>将使用根组件。  </p>
<p>而路由中的如下部分  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    path: &#39;soccer&#39;,  </span><br><span class="line">    component:LayoutsoccerComponent,  </span><br><span class="line">    loadChildren: () &#x3D;&gt; import(&#39;.&#x2F;soccer&#x2F;soccer.module&#39;).then(m &#x3D;&gt; m.SoccerModule),  </span><br><span class="line">    data: &#123;  </span><br><span class="line">        breadcrumb: &#39;足球&#39;,  </span><br><span class="line">        visible: true,  </span><br><span class="line">        menus: SoccerRoutes  </span><br><span class="line">    &#125;,  </span><br><span class="line">    canActivate: [AuthGuard]  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure>
<p>将使用LayoutsoccerComponent组件作为布局组件。  </p>
<h3 id="五、合作开发备注"><a href="#五、合作开发备注" class="headerlink" title="五、合作开发备注"></a>五、合作开发备注</h3><ol>
<li>每成员可基于【三、基于业务功能创建模块】创建自己的模块和页面和组件。  </li>
<li>将该业务功能模块中路由文件中的（已完成路由数组内容提取出来）生成一个***.menu.ts文件。  \<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">    path: &#39;tables&#39;,  </span><br><span class="line">    component: TablesComponent,  </span><br><span class="line">    data: &#123;  </span><br><span class="line">        breadcrumb: &#39;台帐管理&#39;,  </span><br><span class="line">        visible: true  </span><br><span class="line">    &#125;,  </span><br><span class="line">    &#x2F;&#x2F; canActivate: [AuthGuard]  </span><br><span class="line">&#125;,  </span><br><span class="line">&#123;  </span><br><span class="line">    path: &#39;laws&#39;,  </span><br><span class="line">    component: LawsComponent,  </span><br><span class="line">    data: &#123;  </span><br><span class="line">        breadcrumb: &#39;法律法规&#39;,  </span><br><span class="line">        visible: true  </span><br><span class="line">    &#125;,  </span><br><span class="line">    &#x2F;&#x2F; canActivate: [AuthGuard]  </span><br><span class="line">&#125;,  </span><br></pre></td></tr></table></figure></li>
<li>将**<em>.menu.ts引入到**</em>.routing.ts文件中，并并入到routes变量，完成本模块的路由文件修改。  </li>
</ol>
<h3 id="六、路由合并"><a href="#六、路由合并" class="headerlink" title="六、路由合并"></a>六、路由合并</h3><p>新建一个根下的app.menu.ts文件。<br>完成总菜单文件，其中可根据业务功能并入子菜单文件。如果业务功能子菜单要采用不同的<br>模板，请在此处指定。如  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; LayoutComponent &#125; from &#39;.&#x2F;pages&#x2F;layout&#x2F;layout.component&#39;;  </span><br><span class="line">import &#123; LayoutsoccerComponent &#125; from &#39;.&#x2F;pages&#x2F;layoutsoccer&#x2F;layoutsoccer.component&#39;;  </span><br><span class="line">  </span><br><span class="line">...  </span><br><span class="line">    &#123;  </span><br><span class="line">        path: &#39;fund&#39;,  </span><br><span class="line">        component:LayoutComponent,  </span><br><span class="line">        loadChildren: () &#x3D;&gt; import(&#39;.&#x2F;fund&#x2F;fund.module&#39;).then(m &#x3D;&gt; m.FundModule),  </span><br><span class="line">        data: &#123;  </span><br><span class="line">            breadcrumb: &#39;基金&#39;,  </span><br><span class="line">            visible: true,  </span><br><span class="line">            menus: FundRoutes  </span><br><span class="line">        &#125;,  </span><br><span class="line">        canActivate: [AuthGuard]  </span><br><span class="line">    &#125;,  </span><br><span class="line">    &#123;  </span><br><span class="line">        path: &#39;soccer&#39;,  </span><br><span class="line">        component:LayoutsoccerComponent,  </span><br><span class="line">        loadChildren: () &#x3D;&gt; import(&#39;.&#x2F;soccer&#x2F;soccer.module&#39;).then(m &#x3D;&gt; m.SoccerModule),  </span><br><span class="line">        data: &#123;  </span><br><span class="line">            breadcrumb: &#39;足球&#39;,  </span><br><span class="line">            visible: true,  </span><br><span class="line">            menus: SoccerRoutes  </span><br><span class="line">        &#125;,  </span><br><span class="line">        canActivate: [AuthGuard]  </span><br><span class="line">    &#125;,  </span><br><span class="line">    ...  </span><br></pre></td></tr></table></figure>
<p>最后将此app.menu.ts内容并入到根路由中  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; MainRoutes &#125; from &#39;.&#x2F;app.menu&#39;  </span><br><span class="line"></span><br><span class="line">const routes: Routes &#x3D; [  </span><br><span class="line">  ...MainRoutes  </span><br><span class="line"> ];  </span><br></pre></td></tr></table></figure>
<p>如果有样式文件加入，直接在styles.scss中import即可。<br>发现，我的知识库中用到了组件NzTabsModule<br>则必须在knowleges.module.ts中imports,在app.module.ts中imports无效。  </p>
<!--more-->
<h6 id="登录界面"><a href="#登录界面" class="headerlink" title="登录界面"></a>登录界面</h6><p><img src="https://jfcai2008.github.io/images/imgs/login.png" alt="avatar">  </p>
<h6 id="布局1"><a href="#布局1" class="headerlink" title="布局1"></a>布局1</h6><p><img src="https://jfcai2008.github.io/images/imgs/home1.png" alt="avatar">  </p>
<h6 id="布局2"><a href="#布局2" class="headerlink" title="布局2"></a>布局2</h6><p><img src="https://jfcai2008.github.io/images/imgs/home2.png" alt="avatar">  </p>
<h6 id="布局3"><a href="#布局3" class="headerlink" title="布局3"></a>布局3</h6><p><img src="https://jfcai2008.github.io/images/imgs/home3.png" alt="avatar"></p>
<h3 id="七、路由守卫"><a href="#七、路由守卫" class="headerlink" title="七、路由守卫"></a>七、路由守卫</h3><p>参考：<a href="https://www.cnblogs.com/huangenai/p/12191832.html">https://www.cnblogs.com/huangenai/p/12191832.html</a>  </p>
<p>代码地址：<a href="https://github.com/jfcai2008/angular-general">https://github.com/jfcai2008/angular-general</a></p>
]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title>angular的ngStyle</title>
    <url>/2021/01/31/angular%E7%9A%84ngStyle/</url>
    <content><![CDATA[<h3 id="Angular中ngStyle的函数使用"><a href="#Angular中ngStyle的函数使用" class="headerlink" title="Angular中ngStyle的函数使用"></a>Angular中ngStyle的函数使用</h3><p>html文件中，如下使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;tr [ngStyle]&#x3D;&quot;HoldStyle(item)&quot; &gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>ts文件中，可写如下函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HoldStyle(item) &#123;</span><br><span class="line">  let bkcolor &#x3D; &#39;#FFFFFF&#39;</span><br><span class="line">  let status&#x3D;parseInt(item[&#39;flag&#39;])</span><br><span class="line">  if(status&#x3D;&#x3D;2)&#123;</span><br><span class="line">    bkcolor&#x3D;&#39;#9900ff&#39;</span><br><span class="line">  &#125;</span><br><span class="line">  else if(status&#x3D;&#x3D;1)&#123;</span><br><span class="line">    bkcolor&#x3D;&#39;#BFE350&#39; </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    background: bkcolor</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>AngularJS</category>
      </categories>
      <tags>
        <tag>AngularJS</tag>
      </tags>
  </entry>
  <entry>
    <title>几个javascript函数</title>
    <url>/2021/01/31/%E5%87%A0%E4%B8%AAjavascript%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h3 id="对象比较"><a href="#对象比较" class="headerlink" title="对象比较"></a>对象比较</h3><a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 比较对象属性，升降序，附加属性</span><br><span class="line">* @param property</span><br><span class="line">* @param asc</span><br><span class="line">* @param extra</span><br><span class="line">* @returns &#123;function(*, *): (number|number)&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">function compareByKey(property, asc, extra) &#123;</span><br><span class="line">    return function (a, b) &#123;</span><br><span class="line">        var value1 &#x3D; a[property]</span><br><span class="line">        var value2 &#x3D; b[property]</span><br><span class="line">        if (extra &amp;&amp; extra !&#x3D;&#x3D; &#39;&#39;) &#123;</span><br><span class="line">            if (!a[extra]) return -1</span><br><span class="line">            if (!b[extra]) return -1</span><br><span class="line">        &#125;</span><br><span class="line">        return asc ? (value1 &gt; value2 ? 1 : (value1 &#x3D;&#x3D;&#x3D; value2 ? 0 : -1)) : (value1 &gt; value2 ? -1 : (value1 &#x3D;&#x3D;&#x3D; value2 ? 0 : 1))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="去除字符串的所有空格"><a href="#去除字符串的所有空格" class="headerlink" title="去除字符串的所有空格"></a>去除字符串的所有空格</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function removeEmpty(str) &#123;</span><br><span class="line">    return str.replace(&#x2F;\s&#x2F;g, &#39;&#39;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="最大最小函数"><a href="#最大最小函数" class="headerlink" title="最大最小函数"></a>最大最小函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 通过键值查找最大值，返回最大值</span><br><span class="line">* @param arr 对象列表</span><br><span class="line">* @param key 属性</span><br><span class="line">* @returns &#123;*&#125;</span><br><span class="line">* @constructor</span><br><span class="line">*&#x2F;</span><br><span class="line">function MaxByKey(arr, key) &#123;</span><br><span class="line">    let val &#x3D; arr.reduce((num1, num2) &#x3D;&gt; &#123;</span><br><span class="line">            return num1[key] &gt; num2[key] ? num1 : num2</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    return val[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @description 通过键值查找最小值，返回最小值</span><br><span class="line">* @param arr 对象列表</span><br><span class="line">* @param key 属性</span><br><span class="line">* @returns &#123;*&#125;</span><br><span class="line">* @constructor</span><br><span class="line">*&#x2F;</span><br><span class="line">function MinByKey(arr, key) &#123;</span><br><span class="line">    let val &#x3D; arr.reduce((num1, num2) &#x3D;&gt; &#123;</span><br><span class="line">            return num1[key] &lt; num2[key] ? num1 : num2</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    return val[key]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @description 通过键值查找最大值，返回最大值对应对象</span><br><span class="line">* @param arr 列表对象</span><br><span class="line">* @param key 属性</span><br><span class="line">* @returns &#123;*&#125;</span><br><span class="line">* @constructor</span><br><span class="line">*&#x2F;</span><br><span class="line">function MaxByKey2(arr, key) &#123;</span><br><span class="line">    let val &#x3D; arr.reduce((num1, num2) &#x3D;&gt; &#123;</span><br><span class="line">            return num1[key] &gt; num2[key] ? num1 : num2</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;**</span><br><span class="line">* @description 通过键值查找最小值，返回最小值对应对象</span><br><span class="line">* @param arr 列表对象</span><br><span class="line">* @param key 属性</span><br><span class="line">* @returns &#123;*&#125;</span><br><span class="line">* @constructor</span><br><span class="line">*&#x2F;</span><br><span class="line">function MinByKey2(arr, key) &#123;</span><br><span class="line">    let val &#x3D; arr.reduce((num1, num2) &#x3D;&gt; &#123;</span><br><span class="line">            return num1[key] &lt; num2[key] ? num1 : num2</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">    return val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Distinct"><a href="#Distinct" class="headerlink" title="Distinct"></a>Distinct</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 根据键值求distinct</span><br><span class="line">* @param arr</span><br><span class="line">* @param key</span><br><span class="line">* @returns &#123;Map&lt;any, any&gt;&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">function distinctByKey(arr, key) &#123;</span><br><span class="line">    let results &#x3D; new Map()</span><br><span class="line">    arr.forEach(dd &#x3D;&gt; &#123;</span><br><span class="line">        let val &#x3D; results.get(dd[key])</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            &#x2F;&#x2F;val.push(dd)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            results.set(dd[key], dd)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="求和"><a href="#求和" class="headerlink" title="求和"></a>求和</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 根据键值来求和</span><br><span class="line">* @param arr</span><br><span class="line">* @param key</span><br><span class="line">* @returns &#123;*&#125;</span><br><span class="line">* @constructor</span><br><span class="line">*&#x2F;</span><br><span class="line">function SumByKey(arr, key) &#123;</span><br><span class="line">    return arr.reduce((acc, val) &#x3D;&gt; acc + parseFloat(val[key]), 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">* @description 根据键值来分组</span><br><span class="line">* @param arr</span><br><span class="line">* @param key</span><br><span class="line">* @returns &#123;Map&lt;any, any&gt;&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">function groupByKey(arr, key) &#123;</span><br><span class="line">    let results &#x3D; new Map()</span><br><span class="line">    arr.forEach(dd &#x3D;&gt; &#123;</span><br><span class="line">        let val &#x3D; results.get(dd[key])</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            val.push(dd)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            results.set(dd[key], [dd])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return results</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line">* @description obj是个数组，标明arr数组对象的哪些属性来分组</span><br><span class="line">* @param arr</span><br><span class="line">* @param obj</span><br><span class="line">* @returns &#123;Map&lt;any, any&gt;&#125;</span><br><span class="line">*&#x2F;</span><br><span class="line">function groupByObj(arr, obj) &#123;</span><br><span class="line">    let results &#x3D; new Map()</span><br><span class="line">    arr.forEach(dd &#x3D;&gt; &#123;</span><br><span class="line">        let keys &#x3D; []</span><br><span class="line">        let ko &#x3D; &#123;&#125;</span><br><span class="line">        obj.forEach(o &#x3D;&gt; &#123;</span><br><span class="line">            keys.push(dd[o])</span><br><span class="line">            ko[o] &#x3D; dd[o]</span><br><span class="line">        &#125;)</span><br><span class="line">        dd[&#39;__key&#39;] &#x3D; ko</span><br><span class="line">        let key &#x3D; keys.join(&#39;&amp;&#39;)</span><br><span class="line">        let val &#x3D; results.get(key)</span><br><span class="line">        if (val) &#123;</span><br><span class="line">            val.push(dd)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            results.set(key, [dd])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    return results</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Trim"><a href="#Trim" class="headerlink" title="Trim"></a>Trim</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 去左空格;</span><br><span class="line">function ltrim(s) &#123;</span><br><span class="line">    return s.replace(&#x2F;(^\s*)&#x2F;g, &#39;&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 去右空格;</span><br><span class="line">function rtrim(s) &#123;</span><br><span class="line">    return s.replace(&#x2F;(\s*$)&#x2F;g, &#39;&#39;)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 去左右空格;</span><br><span class="line">function trim(s) &#123;</span><br><span class="line">    return s.replace(&#x2F;(^\s*)|(\s*$)&#x2F;g, &#39;&#39;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeChinese(s) &#123;</span><br><span class="line">    var reg &#x3D; &#x2F;[\u4e00-\u9fa5]&#x2F;g;</span><br><span class="line">    return s.replace(reg, &quot;&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客搭建记录</title>
    <url>/2021/01/31/Hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>抄自：<a href="https://huangmb.github.io/2019/05/26/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/">https://huangmb.github.io/2019/05/26/hexo%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E8%AE%B0%E5%BD%95/</a>  </p>
<h2 id="日常操作："><a href="#日常操作：" class="headerlink" title="日常操作："></a>日常操作：</h2><p>发布文章流程<br>1.hexo new post ‘****’<br>2.使用工具编辑上面命令在_post目录下生成的对应md文件.<br>3.hexo g  //生成<br>4.hexo d  //部署  </p>
<h2 id="Hexo博客搭建记录"><a href="#Hexo博客搭建记录" class="headerlink" title="Hexo博客搭建记录"></a>Hexo博客搭建记录</h2><h3 id="Hexo和GitHub-Page"><a href="#Hexo和GitHub-Page" class="headerlink" title="Hexo和GitHub Page"></a>Hexo和GitHub Page</h3><p>Hexo是一个流行的静态博客系统，GitHub Page是GitHub提供的静态页面托管服务，使用Hexo + GitHub Page的组合是个不错的个人博客尤其是技术博客的搭建方案。<br>我个人认为有以下优点：</p>
<a id="more"></a>
<pre><code>GitHub在圈内认同度很高，在Google搜索的权重也非常高；
提供了GitHub的二级域名https://&#123;username&#125;.github.io，可以省去申请域名、备案、维护vps、申请https证书等等一系列烦恼；
Hexo默认使用Markdown进行创作，对于涉及代码的技术博客排版友好；
Hexo拥有丰富的主题和插件，可定制性强，相比简书、掘金等博客网站，更容易做出一个个性有范的博客；
可以方便的使用git进行版本控制；
</code></pre>
<p>缺点也是有的，Page毕竟是个静态托管服务，所以我们无法使用动态语言如Java、PHP等实现复杂功能；GitHub搭建的博客访问速度较慢，但是，翻Q是每个技术人必备的技能。</p>
<p>WordPress也是一个不错的博客系统，不过他是使用php动态语言，GitHub Page不支持，所以，这里也先不讨论WordPress了。</p>
<h3 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h3><p>Hexo是一个Node.Js项目，等下要把静态博客推到GitHub上部署，所以确保电脑已经装了Node.Js、Git环境。<br>环境准备完毕，直接使用下面的命令安装hexo即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<p>安装成功后，新建一个空文件夹作为博客根目录，在该目录下执行hexo init命令进行初始化，一个专属博客就创建好了。</p>
<p>使用命令hexo s运行项目，就可以通过localhost:4000访问我们的博客网站，默认创建了一篇”hello world”的博客。</p>
<p>现在，我们要把它部署到GitHub Page上。</p>
<h3 id="新建GitHub-Page仓库"><a href="#新建GitHub-Page仓库" class="headerlink" title="新建GitHub Page仓库"></a>新建GitHub Page仓库</h3><p>关于GitHub Page的介绍，可以看看官方文档。<br>使用GitHub Page非常简单，只要在你的GitHub上建立一个名为{username}.github.io的空仓库，其中username是你的GitHub用户名，等下我们博客的访问路径也是{username}.github.io。</p>
<p>仓库中不需要存放文件，因为等下Hexo会通过Git部署插件自动把编译生成的静态博客推到这个仓库。</p>
<h3 id="配置Git部署插件"><a href="#配置Git部署插件" class="headerlink" title="配置Git部署插件"></a>配置Git部署插件</h3><p>首先，安装这个插件，在博客根目录下执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<p>然后在根目录下的_config.yml文件夹下配置我们我们刚才创建的GitHub仓库。<br>比如我的是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:huangmb&#x2F;huangmb.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure>
<p>这里的repo是仓库的clone地址，ssh格式而不是https，因为这里没有配置你的git账户信息。</p>
<p>然后执行hexo g -d命令即可发布文章到GitHub上，每次更新文章或者配置后，都可以用这个任务发布，然后在你的博客网站上立刻就能看到最新效果。</p>
<p>如果发布太频繁，可能对SEO不友好，或者容易产生浏览器缓存，如果发现网站没有更新不妨试试清理缓存或者强制刷新。</p>
<h3 id="配置SSH"><a href="#配置SSH" class="headerlink" title="配置SSH"></a>配置SSH</h3><p>为了方便Git部署插件，我们选择ssh的仓库地址，而不是https的仓库url。<br>如果你曾经clone和push过自己GitHub名下的仓库，已经保存了GitHub账户信息也可以直接使用https的clone url，可以跳过这个步骤。</p>
<p>打开上面创建的仓库，点击clone or download按钮查看clone地址。<br><img src="https://jfcai2008.github.io/images/clone.png" alt="avatar"><br>如果你们配置过ssh，就会上面上面以”<a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#105;&#x74;&#x68;&#117;&#98;&#x2e;&#99;&#111;&#x6d;</a>“开头的url，直接使用这个url即可。<br>否则会出现个选项配置ssh，其实就是这个路径<a href="https://github.com/settings/ssh/new">https://github.com/settings/ssh/new</a><br><img src="https://jfcai2008.github.io/images/ssh.png" alt="avatar"><br>到电脑的用户目录下，查看隐藏文件夹.ssh/id_rsa.pub文件，将里面的内容拷贝到上面的Key输入框内，Title随便写。<br>如果找不到.ssh文件夹或者文件夹下不存在id_rsa.pub文件，则是还未创建ssh公钥，关于git ssh可以参考这篇文章 服务器上的 Git - 生成 SSH 公钥</p>
<p>添加回到仓库中就能看到ssh的clone地址，填到hexo git插件配置文件中。</p>
<h3 id="安装NexT主题"><a href="#安装NexT主题" class="headerlink" title="安装NexT主题"></a>安装NexT主题</h3><p>官网地址：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>默认的landspape我感觉不好看，好在Hexo有丰富的主题可选，这里我选了比较热门的NexT主题。<br>就是你们看到的现在这个样子，使用的是NexT主题的Pisces模式，长这个样子。<br><img src="https://jfcai2008.github.io/images/home.png" alt="avatar"></p>
<h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>Hexo的主题安装其实就是把主题包放在在themes文件夹下，每个主题一个文件夹。<br>所以，安装NexT主题，你可以直接把<a href="https://github.com/theme-next/hexo-theme-next%E4%B8%8B%E8%BD%BD%E4%B8%8B%E6%9D%A5%E6%94%BE%E5%9C%A8themes%E6%96%87%E4%BB%B6%E5%A4%B9%E4%B8%8B%E3%80%82">https://github.com/theme-next/hexo-theme-next下载下来放在themes文件夹下。</a><br>这里选择另外一种更好的方式，将NexT仓库使用Git clone到themes文件夹下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;theme-next&#x2F;hexo-theme-next themes&#x2F;next</span><br></pre></td></tr></table></figure>
<p>这样，当Next更新之后，只要使用git pull即可完成更新。</p>
<h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>打开根目录下的_config.yml配置文件，找到theme字段，改为theme: next。<br>重启博客服务，现在主题已经切换到NexT上了。<br>NexT内置了Muse、Mist、Pisces、Gemini四种风格，可以在Next的配置文件/themes/next/_config.xml中找到下面的配置，注释其中一个验证一下效果。修改NexT配置可不需要重启即可看到效果。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#scheme: Muse  </span><br><span class="line">#scheme: Mist  </span><br><span class="line">scheme: Pisces  </span><br><span class="line">#scheme: Gemini  </span><br></pre></td></tr></table></figure>
<p>下面介绍Hexo可能会定制的地方。后面Hexo的配置文件均是指根目录下的_config.yml，NexT的配置文件均是指/themes/next/_config.xml文件。</p>
<h3 id="配置网站基本信息"><a href="#配置网站基本信息" class="headerlink" title="配置网站基本信息"></a>配置网站基本信息</h3><p>在Hexo的配置文件中，找到下面的site模块进行修改。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Site  </span><br><span class="line">title: Bob Huang&#39;s Blog  </span><br><span class="line">subtitle: 很酷的Android工程师  </span><br><span class="line">description: 没事瞎写  </span><br><span class="line">keywords: Android,Kotlin,React Native,Spring MVC,NodeJs  </span><br><span class="line">author: Bob Huang  </span><br><span class="line">language: zh-CN  </span><br><span class="line">timezone: asia&#x2F;shanghai  </span><br></pre></td></tr></table></figure>
<p>因为要部署到GitHub上，这里记得把时区手动指定东八区。</p>
<h3 id="配置头像"><a href="#配置头像" class="headerlink" title="配置头像"></a>配置头像</h3><p>在NexT的配置文件，找到下面的代码，把头像放到images文件夹下，通过url字段配置；rounded字段可以配置圆角。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#Sidebar Avatar  </span><br><span class="line">avatar:  </span><br><span class="line">  url: &#x2F;images&#x2F;avatar.png  </span><br><span class="line">  rounded: true  </span><br></pre></td></tr></table></figure>
<h3 id="配置菜单"><a href="#配置菜单" class="headerlink" title="配置菜单"></a>配置菜单</h3><p>默认的菜单只有”首页”和”归档”，我们可以在NexT的配置文件中找到menu模块。<br>添加菜单</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">menu:  </span><br><span class="line">  home: &#x2F; || home  </span><br><span class="line">  #about: &#x2F;about&#x2F; || user  </span><br><span class="line">  tags: &#x2F;tags&#x2F; || tags  </span><br><span class="line">  categories: &#x2F;categories&#x2F; || th  </span><br><span class="line">  archives: &#x2F;archives&#x2F; || archive  </span><br><span class="line">  #schedule: &#x2F;schedule&#x2F; || calendar  </span><br><span class="line">  about: &#x2F;about&#x2F; || user  </span><br><span class="line">  #sitemap: &#x2F;sitemap.xml || sitemap  </span><br><span class="line">  #commonweal: &#x2F;404&#x2F; || heartbeat  </span><br></pre></td></tr></table></figure>
<p>可以把预置的一些菜单去除注释，比如常用的分类和标签；也可以自己添加其他菜单，比如这里加的关于菜单。<br>菜单的格式如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name: path || icon</span><br></pre></td></tr></table></figure>
<p>前面是菜单的名称，中间的对应的链接路径，||后面是图标的名字，可以去fontawesome.com上找合适的图标或者看看博客内其他地方在用的图标。</p>
<p>可能你会发现标签和分类两个菜单跳转会404，那是因为还没有创建标签和菜单。</p>
<h3 id="新建标签"><a href="#新建标签" class="headerlink" title="新建标签"></a>新建标签</h3><p>执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;tags&quot;</span><br></pre></td></tr></table></figure>
<p>会生成一个source/tags/index.md文件，将其改为:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2019-05-26 17:20:25</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="新建分类"><a href="#新建分类" class="headerlink" title="新建分类"></a>新建分类</h3><p>和标签类似，执行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;categories&quot;</span><br></pre></td></tr></table></figure>
<p>然后source/categories/index.md文件改成</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2019-05-26 17:07:32</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<p>现在标签和菜单不会404了。<br>配置GitHub等社交信息</p>
<p>GitHub有两处地方可以配置，其一是博客右上角的<br>GitHub<br>这是在NexT配置文件的这部分进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">github_banner:</span><br><span class="line">  enable: true</span><br><span class="line">  permalink: https:&#x2F;&#x2F;github.com&#x2F;huangmb</span><br><span class="line">  title: Follow me on GitHub</span><br></pre></td></tr></table></figure>
<p>另一个地方是左下角社交展示区域，可以添加GitHub以及邮箱等其他信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">social:</span><br><span class="line">  GitHub: https:&#x2F;&#x2F;github.com&#x2F;huangmb || github</span><br><span class="line">  E-Mail: mailto:286931810@qq.com || envelope</span><br><span class="line">  #Weibo: https:&#x2F;&#x2F;weibo.com&#x2F;yourname || weibo</span><br><span class="line">  #Google: https:&#x2F;&#x2F;plus.google.com&#x2F;yourname || google</span><br><span class="line">  #Twitter: https:&#x2F;&#x2F;twitter.com&#x2F;yourname || twitter</span><br></pre></td></tr></table></figure>
<h3 id="搜索功能"><a href="#搜索功能" class="headerlink" title="搜索功能"></a>搜索功能</h3><p>虽然是静态博客网站，Hexo也集成了一个本地搜索功能。<br>使用下面的命令安装搜索模块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>
<p>然后在Next的配置文件找到local_search的配置项，将enable改为true即可，你会看到菜单中多了一项搜索。</p>
<h3 id="开始创作"><a href="#开始创作" class="headerlink" title="开始创作"></a>开始创作</h3><p>完事具备，可以开始写作了。在Hexo中，文章是以Markdown方式保存的，所有文章都保存在source/_posts下</p>
<h3 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h3><p>使用命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new post &quot;标题&quot;</span><br></pre></td></tr></table></figure>
<p>即可在_posts文件夹下生成对应的Markdown文件。<br>你可以手动新建Markdown文件，并在文件头部加上博客的声明（称为Front Matter），比如现在这篇文章：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo博客搭建记录</span><br><span class="line">date: 2019-05-26 16:59:36</span><br><span class="line">categories:</span><br><span class="line">- hexo</span><br><span class="line">tags:</span><br><span class="line">- hexo</span><br><span class="line">- 记录</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
<h3 id="使用分类和标签"><a href="#使用分类和标签" class="headerlink" title="使用分类和标签"></a>使用分类和标签</h3><p>正如上面的文件头声明，分类和标签仅需要加上categories和tags字段，标签可以声明多个，而分类声明多个是多级分类的意思，而不是多个分类。</p>
<h3 id="创建时间和更新时间"><a href="#创建时间和更新时间" class="headerlink" title="创建时间和更新时间"></a>创建时间和更新时间</h3><p>在文件头声明date和updated</p>
<p>更多可以使用的属性见front-matter</p>
<h3 id="版权声明"><a href="#版权声明" class="headerlink" title="版权声明"></a>版权声明</h3><p>在NexT的配置文件中，找到creative_commons模块，将enable改为true即可。</p>
<h3 id="使用评论"><a href="#使用评论" class="headerlink" title="使用评论"></a>使用评论</h3><p>本站使用的是Valine作为评论系统，好处是可以匿名评论，支持表情和Markdown。<br>具体安装参考这篇文章。</p>
<h3 id="使用赞赏"><a href="#使用赞赏" class="headerlink" title="使用赞赏"></a>使用赞赏</h3><p>在NexT的配置文件中找到reward_settings模块，将enable改为true，并在下面的reward中的支付宝和微信注释去掉，并改成你的支付宝和微信收款码图片文件名。<br>将微信和支付宝的收款码放在source/images文件夹下。</p>
<h3 id="数据统计"><a href="#数据统计" class="headerlink" title="数据统计"></a>数据统计</h3><p>字数统计</p>
<p>在NexT的配置文件中，找到symbols_count_time，将各属性改为true即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">symbols_count_time:</span><br><span class="line">  separated_meta: true</span><br><span class="line">  item_text_post: true</span><br><span class="line">  item_text_total: false</span><br><span class="line">  awl: 4</span><br><span class="line">  wpm: 275</span><br><span class="line">  suffix: mins.</span><br></pre></td></tr></table></figure>
<h3 id="访客量和访问量"><a href="#访客量和访问量" class="headerlink" title="访客量和访问量"></a>访客量和访问量</h3><p>可以使用busuanzi统计，在NexT的配置文件中找到busuanzi_count并将enable改为true，则在网页底部会有访客统计数据。</p>
<p>如果需要修改显示的样式，比如加上标题，可以修改Next下的layout/_third_party/analytics/busuanzi-counter.swig模版。</p>
<h3 id="百度统计"><a href="#百度统计" class="headerlink" title="百度统计"></a>百度统计</h3><p>前往官网添加一个网站，然后在代码获取下将hm.js后面的xxxx就是你的id拷贝下来。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line"> hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?xxxx&quot;;</span><br><span class="line"> var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0];</span><br></pre></td></tr></table></figure>
<p>在NexT的配置文件中找到baidu_analytics，将注释去掉，值为刚才拷贝的ID。</p>
<h3 id="文章置顶"><a href="#文章置顶" class="headerlink" title="文章置顶"></a>文章置顶</h3><ol>
<li>安装插件<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm uninstall hexo-generator-index --save</span><br><span class="line">npm install hexo-generator-index-pin-top --save</span><br></pre></td></tr></table></figure></li>
<li>修改置顶标签<br>然后在需要置顶的文章的Front-matter中加上top: 10即可。比如下面这篇文章：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: Hexo博客</span><br><span class="line">categories: 软件使用</span><br><span class="line">tags:</span><br><span class="line">  - 软件使用</span><br><span class="line">top: 10</span><br><span class="line">---</span><br></pre></td></tr></table></figure>
说明： 可以多个文章置顶，top值越大，文章排最前</li>
<li>设置置顶标志<br>打开：/themes/next/layout/_macro 目录下的post.swig文件，定位到<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div class&#x3D;&quot;post-meta&quot;&gt;标签下，插入如下代码：</span><br><span class="line">&#123;% if post.top %&#125;</span><br><span class="line">  &lt;i class&#x3D;&quot;fa fa-thumb-tack&quot;&gt;&lt;&#x2F;i&gt;</span><br><span class="line">  &lt;font color&#x3D;7D26CD&gt;置顶&lt;&#x2F;font&gt;</span><br><span class="line">  &lt;span class&#x3D;&quot;post-meta-divider&quot;&gt;|&lt;&#x2F;span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo g # 生成</span><br><span class="line">hexo s # 启动服务</span><br></pre></td></tr></table></figure>
执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些文件将来都是要提交到github去的。<br>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布。</li>
</ol>
<h3 id="如何让博文列表不显示全部内容"><a href="#如何让博文列表不显示全部内容" class="headerlink" title="如何让博文列表不显示全部内容"></a>如何让博文列表不显示全部内容</h3><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p>
<p>答案是在合适的位置加上<!--more-->即可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/01/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
</search>
